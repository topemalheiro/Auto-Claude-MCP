name: PR Labels

# Simple PR labeling - size, area, type, and AC review detection
# CI status is handled by GitHub's built-in check status display
on:
  pull_request_target:
    types: [opened, synchronize, reopened]
  issue_comment:
    types: [created]

permissions:
  pull-requests: write
  contents: read

concurrency:
  group: pr-labels-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
  cancel-in-progress: true

jobs:
  # Add size/area/type labels when PR is opened or updated
  pr-labels:
    name: PR Labels
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request_target'
    timeout-minutes: 5

    steps:
      - name: Add labels
        uses: actions/github-script@v7
        with:
          retries: 3
          script: |
            const CONFIG = {
              SIZE_THRESHOLDS: { XS: 10, S: 100, M: 500, L: 1000 },
              TYPE_MAP: {
                'feat': 'feature', 'fix': 'bug', 'docs': 'documentation',
                'refactor': 'refactor', 'test': 'test', 'ci': 'ci',
                'chore': 'chore', 'perf': 'performance', 'style': 'style', 'build': 'build'
              },
              AREA_PATHS: { frontend: 'apps/frontend/', backend: 'apps/backend/', ci: '.github/' },
              SIZE_LABELS: ['size/XS', 'size/S', 'size/M', 'size/L', 'size/XL'],
              AREA_LABELS: ['area/frontend', 'area/backend', 'area/fullstack', 'area/ci']
            };

            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            const title = pr.title || '';

            console.log(`PR #${prNumber} - Adding labels`);

            const labelsToAdd = [];
            const labelsToRemove = [];

            // 1. Type label from conventional commit
            const match = title.slice(0, 200).match(/^(\w{1,20})(\([^)]{0,50}\))?(!)?:/);
            if (match) {
              const type = match[1].toLowerCase();
              if (CONFIG.TYPE_MAP[type]) {
                labelsToAdd.push(CONFIG.TYPE_MAP[type]);
                console.log(`  Type: ${CONFIG.TYPE_MAP[type]}`);
              }
              if (match[3] === '!') labelsToAdd.push('breaking-change');
            }

            // 2. Area label from changed files
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner, repo, pull_number: prNumber, per_page: 100
            });

            const areas = { frontend: false, backend: false, ci: false };
            for (const file of files) {
              if (file.filename.startsWith(CONFIG.AREA_PATHS.frontend)) areas.frontend = true;
              if (file.filename.startsWith(CONFIG.AREA_PATHS.backend)) areas.backend = true;
              if (file.filename.startsWith(CONFIG.AREA_PATHS.ci)) areas.ci = true;
            }

            let areaLabel = null;
            if (areas.frontend && areas.backend) areaLabel = 'area/fullstack';
            else if (areas.frontend) areaLabel = 'area/frontend';
            else if (areas.backend) areaLabel = 'area/backend';
            else if (areas.ci) areaLabel = 'area/ci';

            if (areaLabel) {
              labelsToAdd.push(areaLabel);
              CONFIG.AREA_LABELS.filter(l => l !== areaLabel).forEach(l => labelsToRemove.push(l));
              console.log(`  Area: ${areaLabel}`);
            }

            // 3. Size label
            const totalLines = (pr.additions || 0) + (pr.deletions || 0);
            let sizeLabel = 'size/XL';
            if (totalLines < CONFIG.SIZE_THRESHOLDS.XS) sizeLabel = 'size/XS';
            else if (totalLines < CONFIG.SIZE_THRESHOLDS.S) sizeLabel = 'size/S';
            else if (totalLines < CONFIG.SIZE_THRESHOLDS.M) sizeLabel = 'size/M';
            else if (totalLines < CONFIG.SIZE_THRESHOLDS.L) sizeLabel = 'size/L';

            labelsToAdd.push(sizeLabel);
            CONFIG.SIZE_LABELS.filter(l => l !== sizeLabel).forEach(l => labelsToRemove.push(l));
            console.log(`  Size: ${sizeLabel} (${totalLines} lines)`);

            // Apply labels
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: prNumber
            });
            const currentNames = currentLabels.map(l => l.name);

            // Remove old labels
            for (const label of labelsToRemove) {
              if (currentNames.includes(label)) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: label });
                } catch (e) { /* ignore */ }
              }
            }

            // Add new labels (filter out already present)
            const toAdd = labelsToAdd.filter(l => !currentNames.includes(l));
            if (toAdd.length > 0) {
              await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: toAdd });
              console.log(`  Added: ${toAdd.join(', ')}`);
            }

            console.log(`âœ… PR #${prNumber} labeled`);

  # Detect Auto-Claude review verdicts from comments
  ac-review:
    name: AC Review Detection
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issue_comment' &&
      github.event.issue.pull_request
    timeout-minutes: 5

    steps:
      - name: Check for Auto-Claude review
        uses: actions/github-script@v7
        with:
          retries: 3
          script: |
            const REVIEW_LABELS = ['Missing AC Approval', 'AC: Approved', 'AC: Changes Requested', 'AC: Blocked', 'AC: Needs Re-review'];
            const AC_PATTERNS = ['ðŸ¤– Auto Claude PR Review', 'Auto Claude Review', 'Auto-Claude Review'];
            const TRUSTED_BOTS = ['github-actions[bot]', 'auto-claude[bot]'];
            const TRUSTED_ASSOC = ['COLLABORATOR', 'MEMBER', 'OWNER'];

            const { owner, repo } = context.repo;
            const prNumber = context.payload.issue.number;
            const comment = context.payload.comment;
            const body = (comment.body || '').slice(0, 5000);

            // Check if trusted source
            const isTrusted = (TRUSTED_BOTS.includes(comment.user.login) && comment.user.type === 'Bot') ||
                              TRUSTED_ASSOC.includes(comment.author_association);

            if (!isTrusted) {
              console.log('Not a trusted source, skipping');
              return;
            }

            // Check if AC comment
            const isAC = AC_PATTERNS.some(p => body.includes(p));
            if (!isAC) {
              console.log('Not an Auto-Claude comment, skipping');
              return;
            }

            // Parse verdict
            let verdict = null;
            if (/Merge Verdict:\s*âœ…/i.test(body) || body.includes('Auto Claude Review - APPROVED')) verdict = 'AC: Approved';
            else if (/Merge Verdict:\s*ðŸŸ /.test(body) || body.includes('NEEDS REVISION')) verdict = 'AC: Changes Requested';
            else if (/Merge Verdict:\s*ðŸ”´/.test(body) || body.includes('BLOCKED')) verdict = 'AC: Blocked';

            if (!verdict) {
              console.log('Could not parse verdict, skipping');
              return;
            }

            console.log(`PR #${prNumber} - AC verdict: ${verdict}`);

            // Update label
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: prNumber
            });
            const labelNames = labels.map(l => l.name);

            if (labelNames.includes(verdict)) {
              console.log('Label already set');
              return;
            }

            // Remove old AC labels
            for (const l of REVIEW_LABELS) {
              if (labelNames.includes(l)) {
                try { await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: l }); } catch (e) {}
              }
            }

            await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [verdict] });
            console.log(`âœ… Updated to: ${verdict}`);
